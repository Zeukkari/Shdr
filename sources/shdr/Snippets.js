// Generated by CoffeeScript 1.12.7
(function() {
  var Snippets;

  Snippets = {
    'TestailuVertex': ['precision highp float;', 'uniform float iTime;', 'uniform float time;', 'attribute vec3 position;', 'attribute vec3 normal;', 'uniform mat3 normalMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'varying vec3 fNormal;', 'varying vec3 fPosition;', '', '', 'void main()', '{', '  fNormal = normalize(normalMatrix * normal);', '  vec4 pos = modelViewMatrix * vec4(position, 2.0);', '  fPosition = pos.xyz;', '', '', '  float animationframes = sin(time*20.0)+1.0;', '  float offsetter2 = sin(fNormal.y*sin(time))+sin(fNormal.x*sin(time*time)*0.01)+1.0;', '  float offsetter3 = sin(fNormal.y*sin((time*time)/5.0)+1.0)*cos(fNormal.x*sin((time*time)/5.0)+1.0);', '  ', '  ', '  vec4 samplePos1 = projectionMatrix * vec4(pos.x*fNormal.y, pos.y*(fNormal.z+fNormal.x), pos.z*(fNormal.y), pos.w);', '  vec4 samplePos2 = projectionMatrix * pos;', '', '  vec4 samplePos3 = samplePos2+(animationframes+0.5)*vec4(fNormal.y*fPosition.y, fNormal.x*fPosition.x, fNormal.z*fPosition.z, 1.0);', '  vec4 samplePos4 = samplePos2 + (animationframes-1.0)/10.0*vec4(samplePos2.x, -samplePos2.y, samplePos2.z*-1.0, -1.0*samplePos2.w*sin(animationframes))*offsetter2/(fNormal.y/fNormal.z);', '', '  float bias1 = abs(animationframes-1.5)*0.1;', '  float bias2 = abs(animationframes-1.0)*(sin(time)*-cos(time));', '', '  if(animationframes<1.5) gl_Position = samplePos2 + 0.5*(samplePos3*bias1 + samplePos4*bias2);', '  if(animationframes<1.0) gl_Position = samplePos2 + 0.1*(samplePos4*bias1 + samplePos3*bias2);', '  if(animationframes>1.5) gl_Position = samplePos2 + bias2*(samplePos3);', '}'].join('\n'),
    'TestailuFragment': ['precision highp float; uniform float time; uniform vec2 resolution;', 'uniform vec4 iMouse;', 'uniform vec3 iResolution;', 'uniform float iTime;', 'varying vec3 fPosition;', 'varying vec3 fNormal;', '', 'const int i_max = 2055;', 'vec2 c = vec2( -0.12256, 0.74486);', 'float er2 = 4.0; // er= er*er escape radius', '', 'vec2 complex_square( vec2 v ) {', '  return vec2(', '  	v.x * v.x - v.y * v.y,', '		v.x * v.y * 2.0', '	);', '}', '', 'void juliaSet( out vec4 fragColor, in vec2 fragCoord )', '{', '    ', '    // compute coordinate ', '  vec2 z = fragCoord.xy - iResolution.xy * 0.5;', '	z *= 2.5 / min( iResolution.x, iResolution.y );', '	', '	float scale = 0.1;', '	int count = 0;', '	for ( int i = 0 ; i < i_max; i++ ) {', '		z = c + complex_square( z );', '		count = i;', '        if ( dot(z,z) > er2 ) {  break; }', '	}', '	', '    if (count == i_max-1) {fragColor = vec4(1.0, 0.0,0.0,1.0);}', '    else  fragColor = vec4(1.0- float( count ) * scale );', '}', '', '#define FLIP_ANIMATION 1', '', 'vec2 hashPt(vec2 p, float timeOffset) {', '   float n = sin(dot(p, vec2(41, 289)));', '   p = fract(vec2(262144, 32768)*n);', '   return sin( p*6.2831853 + timeOffset )*(sin(timeOffset)+1.0)*.5 + .5;', '}', '', '', 'vec2 cellPt(vec2 p) {', '    return p + .5 + (hashPt(p, iTime) - .5)*.5;', '}', '', 'vec2 edgeVoronoi(vec2 p) {', '   vec2 h, pH = floor(p);', '', '   vec2 mh = cellPt(pH) - p;', '   float md = 8.0;', '   for (int j=-1; j<=1; ++j )', '   for (int i=-1; i<=1; ++i ) {', '      h = cellPt(pH + vec2(i,j)) - p;', '      float d = dot(h, h);', '      if (d < md) {', '         md = d;', '         mh = h;', '      }', '   }', '', '   const float eps = .0001;', '   float ed = 8.0;', '', '   for (int j=-1; j<=1; ++j )', '   for (int i=-1; i<=1; ++i ) {', '      h = cellPt(pH + vec2(i,j)) - p;', '      if (dot(h-mh, h-mh) > eps)', '         ed = min( ed, dot( 0.5*(h+mh), normalize(h-mh) ) );', '   }', '   return vec2(sqrt(md),ed);', '}', '', 'vec2 circumCircle(vec2 h1, vec2 h2, vec2 h3)', '{', '   vec2 u = h2 - h1;', '   vec2 v = h3 - h1;', '   float d = u.x*v.y - u.y*v.x;', '   vec2 c = vec2(dot(u,u), dot(v,v)) * (.5 / d);', '   return vec2(c.x*v.y - u.y*c.y, u.x*c.y - c.x*v.x);', '}', '', 'float distLine( vec2 p0, vec2 p1 ) {', '   vec2 e0 = p1 - p0;', '   return dot( p0, normalize(vec2(e0.y,-e0.x)) );', '}', '', 'float delaunayQuad(vec2 h0, vec2 h1, vec2 h2, vec2 h3) {', '   float md = min(', '      min(distLine(h0, h1), distLine(h1, h2)),', '      min(distLine(h2, h3), distLine(h3, h0)));', '   if (md < 0.0)', '      return 8.0; // outside of the quad', '', '   vec2 c = circumCircle(h0, h1, h3);', '   vec2 dh = h2 - h0 - c;', '   float dc = dot(dh, dh) - dot(c,c);', '', '   #if FLIP_ANIMATION', '     float f = clamp(dc*4. + .5, 0., 1.);', '   #else', '     float f = float(dc > 0.0);', '   #endif', '   return min(md, abs(distLine(mix(h0, h3, f), mix(h2, h1, f))));', '}', '', 'float delaunayTriangulation(vec2 p) {', '   vec2 pH = floor(p);', '   vec2 o = cellPt(pH) - p;', '   vec2 h0 = cellPt(pH + vec2(-1, 0)) - p;', '   vec2 h1 = cellPt(pH + vec2(-1,-1)) - p;', '   vec2 h2 = cellPt(pH + vec2( 0,-1)) - p;', '   vec2 h3 = cellPt(pH + vec2( 1,-1)) - p;', '   vec2 h4 = cellPt(pH + vec2( 1, 0)) - p;', '   vec2 h5 = cellPt(pH + vec2( 1, 1)) - p;', '   vec2 h6 = cellPt(pH + vec2( 0, 1)) - p;', '   vec2 h7 = cellPt(pH + vec2(-1, 1)) - p;', '', '   float md =   delaunayQuad(h0,h1,h2,o);', '   md = min(md, delaunayQuad(o,h2,h3,h4));', '   md = min(md, delaunayQuad(h6,o,h4,h5));', '   md = min(md, delaunayQuad(h7,h0,o,h6));', '   return md;', '}', '', 'vec3 lin(vec3 col) { return col*col; }', 'vec3 gamma(vec3 col) { return sqrt(max(vec3(0),col-.03)); }', 'vec3 shade(float tri, float dist, vec2 ev, float ss) {', '   ss *= .6;', '   return', '    mix(', '     mix(', '      mix(', '       mix(', '        mix(', '         lin(vec3(.7,.5,1.))*(dist*2.2 + .1),', '         lin(vec3(.7,.6,1.)),', '         smoothstep(.03+ss,.03-ss,ev.y)*.3', '        ),', '        vec3(0), // edge shadow', '        smoothstep(.05,.01+ss,tri)*.3', '       ),', '       lin(vec3(1.,.7,.3)),', '       max(', '        smoothstep(ss*2.,0.,abs(fract(dist*8.+.5)-.5)/8.)*.7*step(1./16.,dist),', '        smoothstep(.01+ss,.01-ss,tri))', '      ),', '      vec3(0), // seed point shadow', '      smoothstep(.08,min(.075,.05+ss),ev.x)*.7', '     ),', '     lin(vec3(1,.8,.5)),', '     smoothstep(.05+ss,.05-ss,ev.x)', '    );', '}', '', 'void main()', '{', '  vec4 fragCoord = gl_FragCoord;', '  vec4 fragColor;', '  vec4 fragColor2;', '  ', '  float ss = .01;', '  vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss;', '  vec2 ev = edgeVoronoi(p);', '  float tri = delaunayTriangulation(p);', '  float dist = tri; // ev.y; //(iMouse.z > 0.) ? ev.y : tri;', '  vec3 col = shade(tri, tri, ev, ss);', '  vec3 col2 = shade(tri, ev.y, ev, ss);', '  fragColor = vec4(gamma(col), 1);', '  fragColor2 = vec4(gamma(col2), 1.0);', '  gl_FragColor = fragColor * (sin(time)+1.0) + fragColor2 * (cos(time*5.0)+1.0);', '}'].join('\n'),
    'DefaultVertex': ['precision highp float;', 'attribute vec3 position;', 'attribute vec3 normal;', 'uniform mat3 normalMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'varying vec3 fNormal;', 'varying vec3 fPosition;', '', 'void main()', '{', '  fNormal = normalize(normalMatrix * normal);', '  vec4 pos = modelViewMatrix * vec4(position, 1.0);', '  fPosition = pos.xyz;', '  gl_Position = projectionMatrix * pos;', '}'].join('\n'),
    'DefaultFragment': ['precision highp float;', 'uniform float time;', 'uniform vec2 resolution;', 'varying vec3 fPosition;', 'varying vec3 fNormal;', '', 'void main()', '{', '  gl_FragColor = vec4(fNormal, 1.0);', '}'].join('\n'),
    'DemoVertex': ['precision highp float;', 'attribute vec3 position;', '', 'void main()', '{', '  gl_Position = vec4(position, 1.0);', '}'].join('\n'),
    'DemoFragment': ['precision highp float;', '', 'uniform float time;', 'uniform vec2 resolution;', '', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', '', 'void main()', '{', '  vec2 pixel = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;', '  pixel.x *= resolution.x/resolution.y;', '  gl_FragColor = vec4(pixel,.0,1.);', '}'].join('\n'),
    'ExtractCameraPosition': ['vec3 ExtractCameraPos(mat4 a_modelView)', '{', '  mat3 rotMat =mat3(a_modelView[0].xyz,a_modelView[1].xyz,a_modelView[2].xyz);', '  vec3 d =  a_modelView[3].xyz;', '  vec3 retVec = -d * rotMat;', '  return retVec;', '}'].join('\n'),
    'GetDirection': ['vec3 getDirection(vec3 origine, vec2 pixel)', '{', '  vec3 ww = normalize(vec3(0.0) - origine);', '  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));', '  vec3 vv = normalize(cross(ww,uu));', '  return normalize( pixel.x*uu + pixel.y*vv + 1.5*ww );', '}'].join('\n'),
    'Luma': ['vec3 luma = vec3(0.299, 0.587, 0.114);'].join('\n'),
    'Fresnel': ['float fresnel(float costheta, float fresnelCoef)', '{', '  return fresnelCoef + (1. - fresnelCoef) * pow(1. - costheta, 5.);', '}'].join('\n'),
    'Ashikhmin (Dir)': ['float Ashikhmin(vec3 lightDir, vec3 viewDir,  vec3 normal, float exponent, float fresnelCoef)', '{', '  vec3 H = normalize(lightDir+viewDir);', '  float numerateur_s = ( exponent + 1.)/(8.*3.14159) * pow(dot(normal,H), exponent );', '  float denominateur_s = dot(lightDir,H)*(dot(normal,lightDir) + dot(normal, viewDir) - dot(normal, lightDir) * dot(normal, viewDir));', '  float K =  fresnel(dot(normal,lightDir), fresnelCoef) * ( numerateur_s / denominateur_s  ) ;', '  return K;', '}'].join('\n'),
    'Blinn-Phong (Dir)': ['vec2 blinnPhongDir(vec3 lightDir, float lightInt, float Ka, float Kd, float Ks, float shininess)', '{', '  vec3 s = normalize(lightDir);', '  vec3 v = normalize(-fPosition);', '  vec3 n = normalize(fNormal);', '  vec3 h = normalize(v+s);', '  float diffuse = Ka + Kd * lightInt * max(0.0, dot(n, s));', '  float spec =  Ks * pow(max(0.0, dot(n,h)), shininess);', '  return vec2(diffuse, spec);', '}'].join('\n'),
    'OrenNayard (Dir)': ['float OrenNayarDir(vec3 lightDir, vec3 viewDir, vec3 normal, float exponent)', '{', '  float LdotN = dot(lightDir,normal);', '  float VdotN = dot(viewDir,normal);', '  float result = clamp( LdotN, 0. , 1.);', '  float soft_rim = clamp( 1. - VdotN/2., 0. , 1.);', '  float fakey = pow(1. - result * soft_rim , 2.);', '  float fakey_magic = 0.62;', '  fakey = fakey_magic - fakey*fakey_magic;', '  float K =  mix(result, fakey, exponent) ;', '  return K;', '}'].join('\n'),
    'Ward (Dir)': ['float Ward(vec3 lightDir, vec3 viewDir, vec3 normal, float exponent)', '{', '    vec3 H = normalize(lightDir + viewDir);', '    float delta = acos(dot(H,normal));', '    float alpha2 = exponent * exponent;', '    float temp = exp(-pow(tan(delta), 2.) / (alpha2)) / (4. * 3.1415 * alpha2);', '    float temp2 = sqrt(dot(viewDir,normal) * dot(lightDir,normal));', '    float K = temp2 * temp;', '    return K;', '}'].join('\n'),
    'ColorNormal': ['vec3 colorNormal(vec3 col1, vec3 col2, vec3 col3)', '{', '  vec3 n = normalize(fNormal);', '  return clamp(col1*n.x + col2*n.y + col3*n.z,', '              vec3(0.0), vec3(1.0));', '}'].join('\n'),
    'Rimlight': ['vec3 rim(vec3 color, float start, float end, float coef)', '{', '  vec3 normal = normalize(fNormal);', '  vec3 eye = normalize(-fPosition.xyz);', '  float rim = smoothstep(start, end, 1.0 - dot(normal, eye));', '  return clamp(rim, 0.0, 1.0) * coef * color;', '}'].join('\n'),
    'Split': ['vec3 split(vec3 left, vec3 right, float ratio, bool horizontal)', '{', '  float i = float(horizontal);', '  float m = i*gl_FragCoord.x/resolution.x;', '  m += (1.0-i)*gl_FragCoord.y/resolution.y;', '  float d = float(m < ratio);', '  return left*d + right*(1.0-d);', '}'].join('\n'),
    'Transpose (mat3)': ['mat3 transpose( mat3 m )', '{', '  mat3 ret = m;', '  ret[0][1] = m[1][0];', '  ret[0][2] = m[2][0];', '  ret[1][0] = m[0][1];', '  ret[1][2] = m[2][1];', '  ret[2][0] = m[0][2];', '  ret[2][1] = m[1][2];', '  return ret;', '}'].join('\n')
  };

  this.shdr || (this.shdr = {});

  this.shdr.Snippets = Snippets;

}).call(this);
